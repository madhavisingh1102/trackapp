public class Person {

	int age;
	String name;
	
	public String getname()
	{
		return name;
	}
	
	public int getAge()
	{
		return age;
	}

	public Person (int age, String name)
	{
		this.age = age;
		this.name = name;
	}
	
	public String toString()
	{
		return (age+ " " + name + " ");
	}
}


public class Employee extends Person
{

	String department;
	
	public String getDepartment()
	{
		return department;
	}
	
	public Employee (int age , String name ,String department)
	{
		super(age, name);
		this.department = department;
	}
	
	public String toString()
	{
		return (age+" "+ name+" " + department);
		
	}


}




import java.util.ArrayList;
import java.util.List;


public class ListMain {

	public static void main(String[] args) throws InterruptedException {
		
		List<Person> li = new ArrayList<Person>();
		li.add(new Person(20,"Loky"));
		li.add(new Person(21,"Varun"));
		li.add(new Person(22,"Alok"));
		li.add(new Person(23,"Shanky"));
		li.add(new Person(24,"Wardu"));
		List<Employee> e = new ArrayList<Employee>();
		e.add(new Employee(20,"Miky","Auth"));
		e.add(new Employee(21,"Lina","Sonar"));
		e.add(new Employee(22,"Milky","IMPS"));
		e.add(new Employee(20,"Lina","AEPS"));
		e.add(new Employee(24,"lucy","BOM"));
		li.addAll(e);
		List<Person> li1 = new ArrayList<Person>(li);
		li1.add(new Person(30,"Arnav"));
		li1.add(new Person(31,"PK"));
		
		// equals method 
		//System.out.println(li.equals(e));		
		//li1.addAll(e);
		//li.addAll(e1);
		
	for (Person pr:li1)
	{
		System.out.println(pr);
	}
	
	


	}
	}
	
	Imutable Class : Class that does not extendable

It should be : class should be Final 
	      all data members should be final
	      all getter methods should be final
	      There should be no setter method

OBJECT -- Object is root of class hierarchy in java . All class has OBJECT as superclass.

Methods of Object class:

equals() - x.equals(x); It works on value of the object instead reference value. == will work on reference of the object in the memory
toString () - returns the string representation of the object.
example : if written below 
public Employee (int age, String name , String department)
	{
		super(age, name);
		this.department = department;
	}
	
and in main :
	Person p = new Employee( 29 , "Madhavi" , "ITDevelopment" );
		System.out.println(p);
then output will be hascode values of the object. ex : Employee@addbf1

CORRECTION : get the initialized values that we have passed in constructor.

write in employee : 

public Employee (int age, String name , String department)
	{
		super(age, name);
		this.department = department;
	}
	
	public String toString()
	{
		return (age+" "+ name+" " + department); 	
	}

Main will print : Person p = new Employee( 29 , "Madhavi" , "ITDevelopment" );
		System.out.println(p); 

output : 29 Madhavi ITDevelopment

illelegalMonitorStateException - ?

wait , notify, notifyAll() , wait (Long timeout)
======================================================================

Object 
	AbstarctCollection<E>
		AbstractList<E>
			ArrayList<E>

Object
	AbstarctCollection<E>
		AbstractList<E>
			AbstractSequentialList<E>
				LinkedList<E>

List<Person> li = new List<Person>(); not correct will give compiler error as List is an interface

So, List <Persdon> li = new ArrayList<Person>()

LIST  --  remove() will delete the first occurence of the particular element in list.

add () and addAll() -- will append the element at the end of the list.






























Collection Interface :  public interface Collection<E>...
<E> - E will be the type of object contained in collection.

Collection is the root interface in the hierarchy.

SET -- 
LIST
QUEUE
DEQUEUE
MAP
-------
SORTEDSET
SORTEDMAP


